#!/usr/bin/env groovy
import groovy.xml.XmlUtil

// Generate HTML change log from JIRA issues tagged as x.y.z-fixed

class Script {
  static void main(String[] args) {

    if (args.size() != 2) {
      System.err.println("Usage generate-lts-changelog <rev-list> <version>")
      System.exit 1
    }

    String revList = args[0]
    String version = args[1]

    def changelogEntries = getChangelogEntries(version)

    def backported = getBackported(revList)
    def tagged = printTagged(version, changelogEntries)
    backported.sort()
    tagged.sort()

    if (tagged == backported) System.exit(0)

    System.err.println("\n!!!!!!!!\n")

    def tmp = backported.collect()
    tmp.removeAll(tagged)
    if (!tmp.empty) {
      System.err.println("There are issues backported but not tagged in JIRA:")
      tmp.each {
        System.err.println("\t" + getIssueUrl(it))
        System.err.println(["git", "log", revList, "--grep", it].execute().text.readLines().collect { "\t\t${it}\n" }.join())
      }
    }

    tmp = tagged.collect()
    tmp.removeAll(backported)
    if (!tmp.empty) {
      System.err.println("There are issues tagged in JIRA that are not referenced from commits:")
      tmp.each {
        System.err.println("\t" + getIssueUrl(it))
      }
    }

    System.exit(2)
  }

  // Print taged issues and return its list
  static List<String> printTagged(String version, Map<String, String> weeklyChangelog) {
    def tagged = []

    String dump = new URL(
      "https://issues.jenkins.io/sr/jira.issueviews:searchrequest-xml/temp/SearchRequest.xml?jqlQuery=project+%3D+Jenkins+%26%26+labels+in+%28${version}-fixed%29&tempMax=1000"
    ).text

    def rss = new XmlSlurper().parseText(dump)

    def baseline = ((version =~ /\d+[.]\d+/)[ 0 ])

    def pastLtsVersions = (new URL("https://raw.githubusercontent.com/jenkins-infra/jenkins.io/master/content/_data/changelogs/lts.yml").text =~ /version: "(.*)"/).collect {
      it[1]
    }
    pastLtsVersions.remove { it.startsWith(baseline) }
    def predecessor = pastLtsVersions.last()

    print """- version: "${version}"
  date: YYYY-MM-DD
  lts_predecessor: "${predecessor}"
  lts_baseline: "${baseline}" # TODO figure out how to get rid of this
  changes:
"""

    def written = [] // Prevent duplicate entries referring to multiple issues.
    rss.channel.item.each {
      def classes = [
        it.type == "Bug" ? "bug" : "rfe"
      ]
      if (it.priority in ['Critical', 'Blocker']) {
        classes << "major"
      }

      def key = it.key.text()
      def summary = weeklyChangelog[key]
      if (summary == null) {
        println "    - type: ${classes.join(' ')}"
        println "      message: ${XmlUtil.escapeXml(it.summary.toString().trim())}. <<< AUTOGENERATED (${it.link})"
        println "      issue: ${key.replace('JENKINS-', '')}"
      } else {
        if (!written.contains(summary)) {
          print summary
          written << summary
        }
      }

      tagged << key
    }

    return tagged
  }

  // Collect backported issues from commit
  static List<String> getBackported(String revList) {
    def committed = []
    def logProcess = "git log ${revList}".execute()
    if (logProcess.waitFor() != 0) {
      println logProcess.err.text
      System.exit(1)
    }
    (logProcess.text =~ /JENKINS-\d+/).each {
      committed << it
    }
    committed.unique()
    return committed
  }

  static String getIssueUrl(String id) {
    return "https://issues.jenkins.io/browse/$id"
  }

  // Get changelog entries as formulated for weekly releases since the baseline
  static Map<String, String> getChangelogEntries(String versionString) {
    String rawCl = new URL("https://raw.githubusercontent.com/jenkins-infra/jenkins.io/master/content/_data/changelogs/weekly.yml").text

    def ret = [:]
    // Do not manipulate YAML in any more intelligent way in order to preserve the chunks as they are written
    int indent
    List issues = []
    StringBuilder sb
    rawCl.eachLine { l ->
      def currentIndent = (l =~ /^([ ]*)/)[0][1].length()

      if (currentIndent <= indent) { // Shallower indent = and of issue
        issues.each { issue ->
          ret.put("JENKINS-${issue}".toString(), sb.toString())
        }
        // Defensive
        sb = null
        issues = []
      }

      def type = (l =~ /^([ ]*)- type:/)
      def issue = (l =~ /issue:\s*(\d+)/)
      if (type.find()) {
        indent = type[0][1].length()
        sb = new StringBuilder(l)
        sb.append('\n')
      } else if (issue.find()) {
        issues << issue[0][1]
        sb.append(l).append('\n')
      } else if (sb != null) { // in issue chunk
        sb.append(l).append('\n')
      }
    }

    assert ret.size() == (rawCl =~ /issue:/).size()
    return ret
  }
}
